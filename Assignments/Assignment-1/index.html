<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=Generator content="Microsoft Word 15 (filtered)">
<title>COMP 411 Principles of Programming Languages</title>
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:Consolas;
	panose-1:2 11 6 9 2 2 4 3 2 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman",serif;}
h2
	{mso-style-link:"Heading 2 Char";
	margin-right:0in;
	margin-left:0in;
	font-size:18.0pt;
	font-family:"Times New Roman",serif;
	font-weight:bold;}
h3
	{mso-style-link:"Heading 3 Char";
	margin-right:0in;
	margin-left:0in;
	font-size:13.5pt;
	font-family:"Times New Roman",serif;
	font-weight:bold;}
a:link, span.MsoHyperlink
	{font-family:"Arial",sans-serif;
	color:#0000EE;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{font-family:"Arial",sans-serif;
	color:#551A8B;
	text-decoration:underline;}
p
	{margin-right:0in;
	margin-left:0in;
	font-size:12.0pt;
	font-family:"Arial",sans-serif;}
code
	{font-family:"Courier New";}
pre
	{mso-style-link:"HTML Preformatted Char";
	margin:0in;
	margin-bottom:.0001pt;
	font-size:10.0pt;
	font-family:"Courier New";}
tt
	{font-family:"Courier New";}
span.Heading2Char
	{mso-style-name:"Heading 2 Char";
	mso-style-link:"Heading 2";
	font-family:"Calibri Light",sans-serif;
	color:#2E74B5;}
span.Heading3Char
	{mso-style-name:"Heading 3 Char";
	mso-style-link:"Heading 3";
	font-family:"Calibri Light",sans-serif;
	color:#1F4D78;}
span.HTMLPreformattedChar
	{mso-style-name:"HTML Preformatted Char";
	mso-style-link:"HTML Preformatted";
	font-family:Consolas;}
p.class1, li.class1, div.class1
	{mso-style-name:class1;
	margin-right:0in;
	margin-left:0in;
	font-size:12.0pt;
	font-family:"Arial",sans-serif;}
.MsoChpDefault
	{font-size:10.0pt;}
@page WordSection1
	{size:8.5in 11.0in;
	margin:1.0in 1.0in 1.0in 1.0in;}
div.WordSection1
	{page:WordSection1;}
 /* List Definitions */
 ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>

</head>

<body bgcolor=white lang=EN-US link="#0000EE" vlink="#551A8B" alink="#ff0000">

<div class=WordSection1>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0 width="100%"
 style='width:100.0%'>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal style='margin-right:7.5pt'><span style='font-size:14.0pt'><img
  width=122 height=123
  src="https://www.cs.rice.edu/~javaplt/411/22-spring/logo.gif"
  alt="Rice University"></span><sup><span style='font-size:72.0pt'>&nbsp;COMP
  411/511</span></sup><span style='font-size:14.0pt'> </span></p>
  <p class=class1><b><span style='font-size:36.0pt;font-family:"Times New Roman",serif;
  color:#3366FF'>Programming Assignment 1: Parsing and Abstract Syntax</span></b><span
  style='font-size:14.0pt;font-family:"Times New Roman",serif'> </span></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><span style='font-size:14.0pt'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><span style='font-size:14.0pt'>&nbsp;</span></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><span style='font-size:14.0pt'>&nbsp;</span></p>
  </td>
 </tr>
</table>

<h2>Points: 100</h2>

<h2>Overview</h2>

<p><b><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>Preparation</span></b><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> &nbsp; </span></p>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>We
recommend using either IntelliJ or DrJava as your Java IDE for all programming
assignments.  You can download DrJava in the form of the executable jar file </span><span
style='font-family:Consolas'>drjava.jar</span><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'> from <a
href="http://www.cs.rice.edu/~javaplt/drjavarice">http://www.cs.rice.edu/~javaplt/drjavarice</a>. 
When you accept the assignment, GitHub Classroom creates a repository for you
that in initialized to contain all of the support files for the project
including this project description.  DrJava only runs using Java 8.  We
recommend using the Oracle Java 8 SE (build 8u331 or later) with DrJava; on
Windows 10/12, DrJava appears to be slightly more reliable than other
distributions of the Java 8 JDK such as OpenJDK 8.  DrJava has been developed
using builds the Oracle Java 8 SE, most recently build 8u331 and the various
versions of the Java 8 JDK differ in minor respects.  If you use IntelliJ as
your IDE, you can choose any compatible JDK.  Beware of the fact that the
assignments you submit must run from the command line and <i>cannot</i> place
of the methods in the specified API in named packages.  If your program
modifies the specified API (as stipulated in the assignment description below
and codified in the sample test suite Assign1Test.java) by placing the API
methods in named packages, your program does not implement the specified API
and all grading tests will fail.  You can confirm that your program supports
the specified API by running the sample test suite in Assign1Test.java.</span></p>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>Edit the </span><span
style='font-family:Consolas'>README</span><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'> file for your repository to give an
overview of your solution, most notably the API that it supports.  We recommend
that you place your Java source files in the folder named </span><span
style='font-family:Consolas'>src</span><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'> that is already present in your
repository.  We also recommend placing your compiled class files in a separate
folder named </span><span style='font-family:Consolas'>classes</span><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> that is already
present in your repository.  In DrJava, you can define a project with </span><span
style='font-family:Consolas'>src</span><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'> as the source directory and </span><span
style='font-family:Consolas'>classes</span><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'> as the folder where the compiler places
the </span><span style='font-family:Consolas'>.class</span><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> files
corresponding to the source program.  Like more elaborate professional IDEs,
DrJava supports compiling and testing projects.</span></p>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>DrJava is
distributed as a Java </span><code><span style='font-family:Consolas'>jar</span></code><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> file at the web
site <a href="http://drjava.org/">http://drjava.org</a> as well our local site
(<a href="http://www.cs.rice.edu/~javaplt/drjavarice">http://www.cs.rice.edu/~javaplt/drjavarice</a>)
but the local site typically has more recent builds. You can run DrJava on a
Linux or Mac system (with Java JDK 8 installed) by typing </span></p>

<p><code><span style='font-family:Consolas'>java -jar drjava.jar </span></code></p>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>assuming
that </span><tt><span style='font-family:Consolas'>drjava.jar</span></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> is located in the
current directory.  DrJava is not a registered Mac application, so DrJava can
only be run from the command line on Macs. On Windows machines (with a properly
installed Java JDK 8), you can run the </span><tt><span style='font-family:
Consolas'>drjava.jar</span></tt><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>
file simply by double-clicking on the icon. If the Registry has the wrong file
type associated the </span><tt><span style='font-family:Consolas'>.jar</span></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> files, then double-clicking
</span><tt><span style='font-family:Consolas'>.jar</span></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> icons will not
work. In this case, we recommend running DrJava inside the Windows “Command
Prompt” or Powershell using the same command as shown above for Linux. </span></p>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>Documentation
for DrJava is available at <a href="http://drjava.org/">drjava.org</a>. If you
have further questions about DrJava, ask them on Piazza. </span></p>

<p><b><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>Testing</span></b><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> &nbsp; You are
expected to write unit tests for all of your non-trivial methods or functions <em>and
submit your test code as part of your program</em>. DrJava provides integrated
support for JUnit which makes this task easy.  IntelliJ supports integrated
testing using Junit as well.</span></p>

<p><b><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>Task</span></b><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> &nbsp; Your task
is to write a parser in Generic Java (Java 8+) that recognizes expressions in
the pedagogic functional language Jam, which will be defined subsequently. The
course staff has provided a lexer in Java for this assignment. This lexer
returns a larger set of symbols (tokens) than what appears in the Jam Syntax
Definition below. These extra symbols anticipate future extensions to Jam in
later projects. At this point, your parser should simply reject any program
containing one of these extra symbols as ill-formed, just like it would for any
other syntax error.</span></p>

<p><b><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>Java
Support Library</span></b><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>
&nbsp; In the provided support files, the parser's input token stream is
generated by a </span><tt><span style='font-family:Consolas'>Lexer</span></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> object supporting
the 0-ary method </span><tt><span style='font-family:Consolas'>readToken()</span></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'>. The </span><tt><span
style='font-family:Consolas'>readToken()</span></tt><span style='font-size:
14.0pt;font-family:"Times New Roman",serif'> method produces a stream of </span><span
style='font-family:Consolas'>Token</span><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'> objects belonging to various subclasses
of the </span><tt><span style='font-family:Consolas'>Token</span></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> interface. The </span><tt><span
style='font-family:Consolas'>Lexer</span></tt><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'> class supports two constructors: (i) a zero-ary
constructor that converts standard input to a </span><tt><span
style='font-family:Consolas'>Lexer</span></tt><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'> and (ii) a unary constructor </span><tt><span
style='font-family:Consolas'>Lexer(String fileName)</span></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> that converts the
specified file to a </span><tt><span style='font-family:Consolas'>Lexer</span></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'>. The file </span><tt><span
style='font-family:Consolas'>lexer.java</span></tt><span style='font-family:
Consolas'> </span><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>contains
the definition of the </span><tt><span style='font-family:Consolas'>Lexer</span></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> class and the
collection of classes representing tokens (the Java interface type </span><tt><span
style='font-family:Consolas'>Token</span></tt><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'>) and abstract syntax trees (the java
interface type </span><tt><span style='font-family:Consolas'>AST</span></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'>).</span></p>

<h2>The API That Your Program Must Support</h2>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>All
classes visible in the API must be in the default (top-level) package. Using
named packages will break our grading scripts, causing a catastrophic loss of
points on the assignment.  If your program passes the tests in the file
Assign1Test.java in the empty package, it conforms to this standard.</span></p>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>Your
parser should be expressed as a class </span><tt><b><span style='font-family:
Consolas'>Parser</span></b></tt><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>
with constructors </span><tt><b><span style='font-family:Consolas'>Parser(Reader
stream)</span></b></tt><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>
and </span><tt><b><span style='font-family:Consolas'>Parser(String filename)</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> which create
parsers reading the specified stream or file. The </span><tt><b><span
style='font-family:Consolas'>Reader</span></b></tt><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'> version of these constructors is very
convenient when you are testing your parser from the DrJava read-eval-print
loop or from unit test methods.  The </span><b><span style='font-family:Consolas'>String</span></b><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> version supports
parsing Jam programs that reside in files.</span></p>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>The </span><tt><b><span
style='font-family:Consolas'>Parser</span></b></tt><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'> class should contain a public method </span><tt><b><span
style='font-family:Consolas'>AST parse()</span></b></tt><span style='font-size:
14.0pt;font-family:"Times New Roman",serif'> that returns the abstract syntax
tree for the Jam expression in the input stream. Our grading program will print
the output using the method </span><tt><b><span style='font-family:Consolas'>System.out.println</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'>, which invokes
the </span><tt><b><span style='font-family:Consolas'>toString</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> method on its
argument. All of the requisite abstract syntax classes including </span><tt><b><span
style='font-family:Consolas'>toString</span></b></tt><span style='font-size:
14.0pt;font-family:"Times New Roman",serif'> methods are defined in the file </span><b><span
style='font-family:Consolas'>AST.java</span></b><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'> in the empty package.  All of these
support files are located in the folder </span><b><span style='font-family:
Consolas'>src</span></b><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>
in your Assignment 1 repository.</span></p>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>If your
parser encounters an erroneous input (including illegal tokens), simply throw a
</span><tt><b><span style='font-family:Consolas'>ParseException</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> containing a
message explanation explaining the error.  This operation will abort parsing
the program.  The parser in this assignment does not attempt to recover from
syntax errors to continue parsing. This behavior requires a complex
specification including<a name=jam> many special cases, which is beyond the
scope of this assignment.</a></span></p>

<h2>Jam Syntax Definition</h2>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>The
following paragraphs define the parser's input language and the subset that
your parser should recognize as legal Jam programs.</span></p>

<p><strong><span style='font-size:14.0pt;font-family:"Arial",sans-serif'>The
Meta-Language</span></strong><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>
The parser's input language is described using Extended Backus-Naur Form
(EBNF). When reading the notation, keep the following in mind:</span></p>

<ul type=disc>
 <li class=MsoNormal><span style='font-size:14.0pt'>A symbol in the
     meta-language always starts with a capital letter. Therefore, </span><tt><b><span
     style='font-family:Consolas'>Symbol</span></b></tt><span style='font-size:
     14.0pt'> is a symbol in the-meta language, whereas </span><tt><b><span
     style='font-family:Consolas'>literal</span></b></tt><span
     style='font-size:14.0pt'> is the actual text &quot;literal&quot;. Note
     that this convention depends on the fact that no literals in Jam begin
     with a capital letter.</span></li>
 <li class=MsoNormal><span style='font-size:14.0pt'>A phrase </span><tt><b><i><span
     style='font-family:Consolas'>P</span></i></b></tt><span style='font-size:
     14.0pt'> enclosed in braces </span><tt><b><span style='font-family:Consolas'>{
     <i>P</i> }</span></b></tt><span style='font-size:14.0pt'> is optional, <i>i.e.</i>
     both </span><tt><b><i><span style='font-family:Consolas'>P</span></i></b></tt><span
     style='font-size:14.0pt'> and the empty string match </span><tt><b><span
     style='font-family:Consolas'>{ <i>P</i> }</span></b></tt><span
     style='font-size:14.0pt'>.</span></li>
 <li class=MsoNormal><span style='font-size:14.0pt'>A phrase </span><tt><b><i><span
     style='font-family:Consolas'>P</span></i></b></tt><span style='font-size:
     14.0pt'> followed by </span><tt><b><span style='font-family:Consolas'>*</span></b></tt><span
     style='font-size:14.0pt'> is iterated zero or more times, <i>e.g.</i> </span><tt><b><span
     style='font-family:Consolas'>Def*</span></b></tt><span style='font-size:
     14.0pt'> means the concatenation of zero or more </span><tt><b><span
     style='font-family:Consolas'>Def</span></b></tt><span style='font-size:
     14.0pt'> phrases:<br>
     <br>
     </span><tt><b><span style='font-family:Consolas'>Def</span></b></tt><span
     style='font-size:14.0pt'><br>
     </span><tt><b><span style='font-family:Consolas'>Def Def</span></b></tt><span
     style='font-size:14.0pt'><br>
     </span><tt><b><span style='font-family:Consolas'>... </span></b></tt><span
     style='font-size:14.0pt'><br>
     and so on, including the empty string. </span></li>
 <li class=MsoNormal><span style='font-size:14.0pt'>A phrase </span><tt><b><i><span
     style='font-family:Consolas'>P</span></i></b></tt><span style='font-size:
     14.0pt'> followed by </span><tt><b><span style='font-family:Consolas'>+</span></b></tt><span
     style='font-size:14.0pt'> is iterated one or more times, <i>e.g.</i> </span><tt><b><span
     style='font-family:Consolas'>Def+</span></b></tt><span style='font-size:
     14.0pt'> means the concatenation of one or more </span><tt><b><span
     style='font-family:Consolas'>Def</span></b></tt><span style='font-size:
     14.0pt'> phrases:<br>
     </span><tt><b><span style='font-family:Consolas'>Def</span></b></tt><span
     style='font-size:14.0pt'><br>
     </span><tt><b><span style='font-family:Consolas'>Def Def</span></b></tt><span
     style='font-size:14.0pt'><br>
     </span><tt><b><span style='font-family:Consolas'>... </span></b></tt><span
     style='font-size:14.0pt'><br>
     and so on, but <strong>not</strong> the empty string.</span></li>
 <li class=MsoNormal><span style='font-size:14.0pt'>If a phrase </span><tt><b><i><span
     style='font-family:Consolas'>P</span></i></b></tt><span style='font-size:
     14.0pt'> enclosed in brackets </span><tt><b><span style='font-family:Consolas'>{
     <i>P</i> }</span></b></tt><span style='font-size:14.0pt'> is followed by a
     </span><tt><b><span style='font-family:Consolas'>*</span></b></tt><span
     style='font-size:14.0pt'> or </span><tt><b><span style='font-family:Consolas'>+</span></b></tt><span
     style='font-size:14.0pt'>, the braces are simply denote grouping: the
     enclosed phrase is iterated as specified by the * or + symbol. For
     example, </span><tt><b><span style='font-family:Consolas'>{ A B }*</span></b></tt><span
     style='font-size:14.0pt'> is matched by zero or more concatenations of A
     B: </span><tt><b><span style='font-family:Consolas'>A B</span></b></tt><span
     style='font-size:14.0pt'><br>
     </span><tt><b><span style='font-family:Consolas'>A B A B</span></b></tt><span
     style='font-size:14.0pt'><br>
     and so on, as well as the empty string, but <strong>not</strong> </span><tt><b><span
     style='font-family:Consolas'>A</span></b></tt><span style='font-size:14.0pt'>
     or </span><tt><b><span style='font-family:Consolas'>A B A</span></b></tt><span
     style='font-size:14.0pt'>.</span></li>
 <li class=MsoNormal><span style='font-size:14.0pt'>If something that is
     interpreted as part of the meta language should be interpreted literally
     as part of the language we are describing, it will be enclosed in <i>single</i>
     quotes. Therefore, </span><tt><b><span style='font-family:Consolas'>'A'</span></b></tt><span
     style='font-size:14.0pt'> is the actual letter &quot;A&quot;, not the
     symbol </span><tt><b><span style='font-family:Consolas'>A</span></b></tt><span
     style='font-size:14.0pt'> in the meta language, and </span><tt><b><i><span
     style='font-family:Consolas'>P</span></i></b></tt><tt><b><span
     style='font-family:Consolas'> '*'</span></b></tt><span style='font-size:
     14.0pt'> is the phrase </span><tt><b><i><span style='font-family:Consolas'>P</span></i></b></tt><span
     style='font-size:14.0pt'> followed by an actual asterisk, and does not
     mean that the phase </span><tt><b><i><span style='font-family:Consolas'>P</span></i></b></tt><span
     style='font-size:14.0pt'> should be repeated zero or more times, as
     described above.</span></li>
</ul>

<p><b><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>The
Input Language</span></b><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>
&nbsp; The parser's input language (modulo a few changes described in the
section (</span><b><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>Left-associative
Binary Operators</span></b><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>)
is </span><tt><b><span style='font-family:Consolas'>Input</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> where: </span></p>

<pre style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:
Consolas'>Input ::= Token*</span></b></pre><pre style='margin-left:45.8pt'><b><span
style='font-size:12.0pt;font-family:Consolas'>Token ::= AlphaOther AlphaOtherNumeric* | Delimiter | Operator | Int</span></b></pre>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>The lexer
recognizes keywords, delimiters (parentheses, commas, semicolons), primitive
operations, identifiers, and numbers.</span></p>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>Adjacent
tokens must be separated by whitespace (a non-empty sequence of spaces, tabs,
and newlines) unless one of the tokens is a delimiter or operator. In identifying
operators, the lexer chooses the longest possible match. Hence, </span><tt><b><span
style='font-family:Consolas'>&lt;=</span></b></tt><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'> is interpreted as a single token rather
than </span><tt><b><span style='font-family:Consolas'>&lt;</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> followed by </span><tt><b><span
style='font-family:Consolas'>=</span></b></tt><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'>.</span></p>

<pre style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:
Consolas'>Lower             ::= a | b | c | d | ... | z</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>Upper             ::= 'A' | 'B' | 'C' | 'D' | ... | 'Z'      </span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>Other             ::= ? | _</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>Digit             ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>Alpha             ::= Upper | Lower</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>AlphaOther        ::= Alpha | Other</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>AlphaOtherNumeric ::= AlphaOther | Digit</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>Delimiter         ::= ( | ) | [ | ] | , | ;</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>Operator          ::= '+' | - | ~ | '*' | / | = | != | &lt; | &gt; | &lt;= | &gt;= | &amp; | '|' | :=</span></b></pre>

<p><b><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>Note</span></b><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'>: The terminal
symbols 'A', </span><tt><b><span style='font-family:Consolas'>'B'</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'>, ... are enclosed
in single quotation marks because </span><tt><b><span style='font-family:Consolas'>A</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'>, </span><tt><b><span
style='font-family:Consolas'>B</span></b></tt><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'>, ..., would automatically be the names of
non-terminal symbols in our notation system. For essentially the same reason,
we enclose the symbols </span><tt><b><span style='font-family:Consolas'>'+'</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'>, </span><tt><b><span
style='font-family:Consolas'>'*'</span></b></tt><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'>, and </span><tt><b><span
style='font-family:Consolas'>'|'</span></b></tt><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'> in single quotation marks; these symbols
without quotation marks are metasymbols in the notation scheme described above.
</span></p>

<p><b><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>Jam</span></b><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> &nbsp; The set of
legitimate Jam phrases is the subset of the potential inputs consisting the
expressions </span><tt><b><span style='font-family:Consolas'>Exp </span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'>defined by the
following grammar: </span></p>

<p><em><b><span style='font-size:14.0pt;font-family:"Arial",sans-serif'>Expressions</span></b></em></p>

<pre style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:
Consolas'>Exp         ::= Term { Binop Exp }</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>              | if Exp then Exp else Exp</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>              | let Def+ in Exp</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>              | map IdList to Exp</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>Term        ::= Unop Term</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>              | Factor { ( ExpList ) }</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>              | Empty</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>              | Int</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>              | Bool</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>Factor      ::= ( Exp ) | Prim | Id</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>ExpList     ::= { PropExpList }</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>PropExpList ::= Exp { , Exp }*</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>IdList      ::= { PropIdList }</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>PropIdList  ::= Id { , Id}*</span></b></pre>

<p><em><b><span style='font-size:14.0pt;font-family:"Arial",sans-serif'>Definitions</span></b></em></p>

<pre><b><span style='font-size:12.0pt;font-family:Consolas'>&nbsp;</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>Def ::= Id := Exp ;</span></b></pre>

<p><em><b><span style='font-size:14.0pt;font-family:"Arial",sans-serif'>Primitive
Constants, Operators, and Operations</span></b></em><b><span style='font-size:
14.0pt;font-family:"Times New Roman",serif'> </span></b></p>

<pre><b><span style='font-size:12.0pt;font-family:Consolas'>&nbsp;</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>Empty ::= empty</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>Bool  ::= true | false</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>Unop  ::= Sign | ~</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>Sign  ::=  '+' | -</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>Binop ::= Sign | '*' | / | = | != | &lt; | &gt; | &lt;= | &gt;= | &amp; | '|'</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>Prim  ::= number? | function? | list? | empty? | cons? | cons | first | rest | arity</span></b></pre>

<p><em><b><span style='font-size:14.0pt;font-family:"Arial",sans-serif'>Identifiers</span></b></em></p>

<pre style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:
Consolas'>Id ::= AlphaOther {AlphaOther | Digit}*</span></b></pre>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>Please
note that </span><tt><b><span style='font-family:Consolas'>Id</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> does <strong>not</strong>
contain the anything that matches </span><tt><b><span style='font-family:Consolas'>Prim</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> or the keywords </span><tt><b><span
style='font-family:Consolas'>if</span></b></tt><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'>, </span><tt><b><span style='font-family:
Consolas'>then</span></b></tt><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>,
</span><tt><b><span style='font-family:Consolas'>else</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'>, </span><tt><b><span
style='font-family:Consolas'>map</span></b></tt><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'>, </span><tt><b><span style='font-family:
Consolas'>to</span></b></tt><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>,
</span><tt><b><span style='font-family:Consolas'>let</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'>, </span><tt><b><span
style='font-family:Consolas'>in</span></b></tt><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'>, </span><tt><b><span style='font-family:
Consolas'>empty</span></b></tt><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>,
</span><tt><b><span style='font-family:Consolas'>true</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'>, and </span><tt><b><span
style='font-family:Consolas'>false</span></b></tt><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'>.</span></p>

<p><em><b><span style='font-size:14.0pt;font-family:"Arial",sans-serif'>Numbers</span></b></em></p>

<pre style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:
Consolas'>Int ::= Digit+</span></b></pre>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>The
preceding grammar requires one symbol lookahead in a few situations. The Java
lexer in our support code includes a method </span><tt><b><span
style='font-family:Consolas'>Token peek()</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> that behaves
exactly like the method </span><tt><b><span style='font-family:Consolas'>Token
readToken()</span></b></tt><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>
except for the fact that it leaves the the scanned token at the front of the input
stream (in contrast </span><tt><b><span style='font-family:Consolas'>readToken()</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> removes the
scanned token from the input stream).</span></p>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>The Java
file </span><tt><b><span style='font-family:Consolas'>lexer.java</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> defines all of
the abstract syntax classes required to represent Jam programs using the
composite design pattern. There is one constructor for each fundamentally
different form of expression in the definition of Jam syntax given above. Some
primitive (non-recursive) abstract syntax classes are the same the
corresponding token classes. </span></p>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>For
example, suppose the Jam program under consideration is</span></p>

<pre style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:
Consolas'>f(x) + (x * 12))</span></b></pre>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>The
abstract syntax representation for this program phrase is:</span></p>

<pre style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:
Consolas'>new BinOpApp(</span></b></pre><pre style='margin-left:45.8pt'><b><span
style='font-size:12.0pt;font-family:Consolas'>       new Op(&quot;+&quot;),</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>       new App(new Variable(&quot;f&quot;), new AST[] { new Variable(&quot;x&quot;) }),</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>       new BinOpApp(new Op(&quot;*&quot;), new Variable(&quot;x&quot;), new IntConstant(12))</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>     )</span></b></pre>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>This
construction does not tell the whole story. The lexer is guaranteed to always
return the <i>same</i> object for a given operator. Similarly, there is only
copy of each variable encountered by the lexer. Hence, there is only one copy
of the </span><tt><b><span style='font-family:Consolas'>Operator</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> &quot;+&quot;,
one copy of the </span><tt><b><span style='font-family:Consolas'>Operator</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> &quot;*&quot;,
one copy of the </span><tt><b><span style='font-family:Consolas'>Variable</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> &quot;x&quot;, <i>etc</i>.
As a result, the </span><tt><b><span style='font-family:Consolas'>==</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> operator in Java
can be used to compare operators and variables. Note that the </span><tt><b><span
style='font-family:Consolas'>Operator</span></b></tt><span style='font-size:
14.0pt;font-family:"Times New Roman",serif'>s &quot;+&quot; and &quot;-&quot;
can be used either as unary or binary operators. </span></p>

<h3>Left-associative Binary Operators</h3>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>The
preceding grammar for Jam has an annoying flaw. To make the language easy to
parse using recursive descent (top-down) parsing, we used right recursion in
the definition of arithmetic expressions (</span><tt><b><span style='font-family:
Consolas'>Exp</span></b></tt><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>).
(Left recursion forces infinite looping in top-down parsing.) But right
recursion yields right-associative ASTs (where computation must be performed
right to left), while the usual mathematical convention in arithmetic
expressions is that binary operators are left-associative (where computation
must be performed left to right). There is a widely-used trick in writing
grammars for top-down parsing using syntax diagrams that avoids this problem.
The trick is replace right recursion in a simple production (only one
alternative on the right hand side) by iteration: an edge looping back to the
input edge of the diagram. We used this trick in generating the syntax diagrams
for </span><tt><b><span style='font-family:Consolas'>ExpList</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> and </span><tt><b><span
style='font-family:Consolas'>IdList</span></b></tt><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'> for our original grammar. Given our
original Jam grammar, we can convert the production </span></p>

<pre style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:
Consolas'>Exp         ::= Term { Binop Exp } | ...</span></b></pre><pre><b><span
style='font-size:12.0pt;font-family:Consolas'>&nbsp;</span></b></pre>

<p class=MsoNormal><span style='font-size:14.0pt'>to </span></p>

<pre><b><span style='font-size:12.0pt;font-family:Consolas'>&nbsp;</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>Exp         ::= BinaryExp | ...</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>BinaryExp   ::= Term { Binop BinaryExp }</span></b></pre><pre><b><span
style='font-size:12.0pt;font-family:Consolas'>&nbsp;</span></b></pre>

<p class=MsoNormal><span style='font-size:14.0pt'>at the cost of excluding
chains of binary operations terminating in an expression other than a term.
Then this revised grammar can be represented using syntax diagrams that define </span><tt><b><span
style='font-family:Consolas'>BinaryExp</span></b></tt><span style='font-size:
14.0pt'> iteratively (just like </span><tt><b><span style='font-family:Consolas'>PropExpList</span></b></tt><span
style='font-size:14.0pt'> in the original grammar). </span></p>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>The
preceding definition of </span><tt><b><span style='font-family:Consolas'>BinaryExp</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> generates the
same set of strings as the extended rule: </span></p>

<pre><b><span style='font-size:12.0pt;font-family:Consolas'>&nbsp;</span></b></pre><pre
style='margin-left:45.8pt'><b><span style='font-size:12.0pt;font-family:Consolas'>BinaryExp ::= Term { BinOp Term }*</span></b></pre><pre><b><span
style='font-size:12.0pt;font-family:Consolas'>&nbsp;</span></b></pre>

<p class=MsoNormal><span style='font-size:14.0pt'>which is ambiguous about left
or right associativity. When iteration is used to recognize a </span><tt><b><span
style='font-family:Consolas'>BinaryExp</span></b></tt><span style='font-size:
14.0pt'>, the parsing process can construct a left-associative tree since the
tree is constructed left-to-right (each new </span><tt><b><span
style='font-family:Consolas'>Binop</span></b></tt><span style='font-size:14.0pt'>
adds a new root to the AST).  This convention make the syntax diagram
formulation of our Jam grammar deterministic and unambiguous.</span></p>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>The file <a
href="https://github.com/RiceComp411/Assignment-1-Master-2023/blob/master/docs/JamSyntaxDiagrams.pdf">JamSyntaxDiagrams</a>
contains iterative syntax diagrams corresponding to the original left
associative version of the Jam language. These diagams precisely describe the
syntax of Jam and how we want the parser to behave. Of course, this language
eliminates a few quirky inputs from the language based on our original grammar.
Your parser should treat these quirky inputs as erroneous. </span></p>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>It is
possible to write syntax diagrams that treat binary expressions iteratively and
still allow arbitrary expressions at the end of the binary expression. But the
corresponding grammar and syntax diagrams are much more complex. So we have not
followed this design choice in creating the revised syntax for Jam. In fact, we
view our Jam grammar as a case study showing that pure context-free grammars
are not quite the right formalism for expressing easily parsed program syntax.
Syntax diagrams where iteration is always left-associative (equivalent to
extended context-free-grammars where iteration always expands into
left-associative parse trees) are much better. I am not aware of a rigorous
exposition of such extended BNF grammars in the literature; I suspect that most
theoretical computer scientists would not find such an exposition very
interesting even though the standard notion of parsing language specified by a
context-free grammar is an imperfect formalization of practical parsing. </span></p>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>Write
your parser to produce left-associative ASTs for arithmetic expressions. If
your parser implements either of the &quot;revised&quot; syntax diagram
definitions given above (which are equivalent) using </span><tt><b><span
style='font-family:Consolas'>while</span></b></tt><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'> loops for iteration and constructs the
corresponding abstract syntax trees in a functional style (no mutation of trees
in theconstruction process), your parser will naturally build syntax trees that
are left-associative.</span></p>

<h2>Testing and Submitting Your Program</h2>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>The </span><span
style='font-family:Consolas'>src</span><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'> folder in the provided code base includes
some Junit4 test classes which are not comprehensive.  You need to add more
test cases; you need to check every production in the grammar.  If a production
involves iteration or recursion, you need to test the base cases as well as
simple inductive constructions.</span></p>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>Edit the </span><tt><b><span
style='font-family:Consolas'>README</span></b></tt><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'> file for your repository so that it</span></p>

<ul type=disc>
 <li class=MsoNormal><span style='font-size:14.0pt'>outlines the organization
     of your program, </span></li>
 <li class=MsoNormal><span style='font-size:14.0pt'>specifies any compatible
     additions that you made the provided API (not generally necessary), and</span></li>
 <li class=MsoNormal><span style='font-size:14.0pt'>specifes what testing
     process you used to confirm the correctness of your program.</span></li>
</ul>

<p class=MsoNormal><span style='font-size:14.0pt'>Note that the README file is
a GitHub “MarkDown” file, text augmented by a few simple formatting
annotations.  MarkDown (MD) is much less powerful than HTML but much easier to
use.  The webpage <b><a
href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">markdown-cheat-sheet</a></b>
is a good summary for learning MarkDown and a useful reference.</span></p>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>We do not
recommend using separate test data files because it creates more opportunities
for incidental errors when testing your solution.  Unless you are testing how
well your program scales to large inputs, they are generally unnecessary.  All
JUnit test classes submitted for grading should be compatible with a generic
solution that conforms to the public interface provided by the stub files in
the provided support code. In other words, we should be able to compile and run
your unit tests against a reference solution used for grading, which has the
same public interface as the support code. Your test classes should be defined
in files matching the pattern </span><tt><b><span style='font-family:Consolas'>&quot;*Assign#Test.java&quot;</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'>, where </span><tt><b><span
style='font-family:Consolas'>&quot;#&quot;</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> is the current
assignment number. For example, </span><tt><b><span style='font-family:Consolas'>&quot;MyAssign2Test.java&quot;</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'> would be a valid
name for Assignment 2 unit tests. If you want to include other tests that you
do not want graded (e.g., to test your private interfaces), then simply use a
different suffix than &quot;Test&quot; for the test class names (e.g., </span><tt><b><span
style='font-family:Consolas'>&quot;Assign1Test#.java&quot;</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'>). If you have
additional utility classes that are required dependences of your unit test
classes, please name those classes using the pattern </span><tt><b><span
style='font-family:Consolas'>&quot;*Assign#TestSupport.java&quot;</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'>, which signals
that the class is required to support your unit tests, but is not a unit test
class that should be independently launched. You may also include test support
files with names matching the pattern </span><tt><b><span style='font-family:
Consolas'>&quot;*AssignAllTestSupport.java&quot;</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'>, which can
contain common test support code that can be reused across multiple assignment
submissions without needing to rename the file.  Note that our class solutions
to the assignments do not rely on such utility classes.</span></p>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>Each
method in your program should include a short comment stating precisely what it
does. For routines that parse a particular form of program phrase, the comment
should provide the grammar rules describing that form.</span></p>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>You
obviously do not need to “submit” your program, since you are creating it
inside a repository on the ownership of the course staff.  We can easily access
all student repositories.</span></p>

<!-- ONLY WORKS IN BASH
  <p>Note if <tt>turnin411</tt> is not on your path, you will need to add <tt>~comp411/bin</tt> to your path:</p>
  <pre>export PATH=$PATH:~comp411/bin</pre>
  -->

<h2>Implementation Hints</h2>

<p><span style='font-size:14.0pt;font-family:"Times New Roman",serif'>The </span><tt><b><span
style='font-family:Consolas'>toString()</span></b></tt><span style='font-size:
14.0pt;font-family:"Times New Roman",serif'> methods for each </span><tt><b><span
style='font-family:Consolas'>AST</span></b></tt><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'> class effectively provide an unparser for
</span><tt><b><span style='font-family:Consolas'>AST</span></b></tt><span
style='font-size:14.0pt;font-family:"Times New Roman",serif'>s. You can
directly compare test input strings with output </span><b><span
style='font-family:Consolas'>AST</span></b><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'>s by unparsing the </span><b><span
style='font-family:Consolas'>AST</span></b><span style='font-size:14.0pt;
font-family:"Times New Roman",serif'>s (using </span><tt><b><span
style='font-family:Consolas'>toString()</span></b></tt><span style='font-size:
14.0pt;font-family:"Times New Roman",serif'>). The two strings should match up
to differences in whitespace, new lines, and parentheses using for grouping
which may force you to slightly reformat your input strings.</span></p>

</div>

</body>

</html>
